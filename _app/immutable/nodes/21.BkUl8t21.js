import{s as re,x as X,e as V,t as te,a as w,b as N,f as se,h as ne,d as m,c as P,g as ee,o as we,i as $,j as q,B as ye,y as Y,k as ce,a4 as Pe,K as ie,z as ae,l as fe}from"../chunks/scheduler.CKOt2LAZ.js";import{S as ue,i as he,e as Z,c as E,a as I,m as M,t as T,b as H,d as O,f as pe,g as me}from"../chunks/index.BDxETPF1.js";import{B as We,e as oe,u as de,o as $e}from"../chunks/Geocoder.svelte_svelte_type_style_lang.AsJd5zsu.js";import{S as _e}from"../chunks/SecondaryButton.4VAZn6vt.js";import{s as B}from"../chunks/data.C70Kkrvn.js";import"../chunks/paths.BSN23lf9.js";import{N as Se}from"../chunks/NumberInput.BmEmZ4gQ.js";import{T as le}from"../chunks/TextArea.DloLv3gT.js";import{W as Ce}from"../chunks/WarningButton.DygY43-6.js";import{T as De}from"../chunks/TextInput.UMdR6Vx1.js";function Te(s){let t;return{c(){t=te("Delete")},l(i){t=ne(i,"Delete")},m(i,e){$(i,t,e)},d(i){i&&m(t)}}}function He(s){let t,i,e,c=s[0]+1+"",p,l,f,d,g,u,h="Cross-Sections Possible: TODO",_,y,S,z,C,v,R,W,D;function x(o){s[3](o)}let U={label:"Available width (m)",width:3,min:0};s[1].checks.homogeneousSections[s[0]].availableWidth!==void 0&&(U.value=s[1].checks.homogeneousSections[s[0]].availableWidth),f=new Se({props:U}),X.push(()=>Z(f,"value",x));function L(o){s[4](o)}let F={label:"What will need to change to fit this in? Please leave a justification if space has been taken away from pedestrians or cyclists, or if shared use cycle tracks are proposed."};s[1].checks.homogeneousSections[s[0]].notes1!==void 0&&(F.value=s[1].checks.homogeneousSections[s[0]].notes1),y=new le({props:F}),X.push(()=>Z(y,"value",L));function j(o){s[5](o)}let b={label:"Where only the absolute minimum cross-section is possible, what (if anything) could change to fit in the desirable minimum cross-section? Where there is insufficient space even for the absolute minimum cross-section, what (if anything) could change to allow this to be implemented? Otherwise, what else could be implemented as an alternative?"};return s[1].checks.homogeneousSections[s[0]].notes2!==void 0&&(b.value=s[1].checks.homogeneousSections[s[0]].notes2),C=new le({props:b}),X.push(()=>Z(C,"value",j)),W=new Ce({props:{$$slots:{default:[Te]},$$scope:{ctx:s}}}),W.$on("click",s[6]),{c(){t=V("div"),i=V("u"),e=te("Cross-section #"),p=te(c),l=w(),E(f.$$.fragment),g=w(),u=V("p"),u.textContent=h,_=w(),E(y.$$.fragment),z=w(),E(C.$$.fragment),R=w(),E(W.$$.fragment),this.h()},l(o){t=N(o,"DIV",{class:!0});var r=se(t);i=N(r,"U",{});var A=se(i);e=ne(A,"Cross-section #"),p=ne(A,c),A.forEach(m),l=P(r),I(f.$$.fragment,r),g=P(r),u=N(r,"P",{"data-svelte-h":!0}),ee(u)!=="svelte-9mzn0s"&&(u.textContent=h),_=P(r),I(y.$$.fragment,r),z=P(r),I(C.$$.fragment,r),R=P(r),I(W.$$.fragment,r),r.forEach(m),this.h()},h(){we(t,"class","svelte-d3f4io")},m(o,r){$(o,t,r),q(t,i),q(i,e),q(i,p),q(t,l),M(f,t,null),q(t,g),q(t,u),q(t,_),M(y,t,null),q(t,z),M(C,t,null),q(t,R),M(W,t,null),D=!0},p(o,[r]){(!D||r&1)&&c!==(c=o[0]+1+"")&&ye(p,c);const A={};!d&&r&3&&(d=!0,A.value=o[1].checks.homogeneousSections[o[0]].availableWidth,Y(()=>d=!1)),f.$set(A);const J={};!S&&r&3&&(S=!0,J.value=o[1].checks.homogeneousSections[o[0]].notes1,Y(()=>S=!1)),y.$set(J);const K={};!v&&r&3&&(v=!0,K.value=o[1].checks.homogeneousSections[o[0]].notes2,Y(()=>v=!1)),C.$set(K);const Q={};r&128&&(Q.$$scope={dirty:r,ctx:o}),W.$set(Q)},i(o){D||(T(f.$$.fragment,o),T(y.$$.fragment,o),T(C.$$.fragment,o),T(W.$$.fragment,o),D=!0)},o(o){H(f.$$.fragment,o),H(y.$$.fragment,o),H(C.$$.fragment,o),H(W.$$.fragment,o),D=!1},d(o){o&&m(t),O(f),O(y),O(C),O(W)}}}function Ae(s,t,i){let e;ce(s,B,u=>i(1,e=u));let{i:c}=t,p=Pe();function l(u){s.$$.not_equal(e.checks.homogeneousSections[c].availableWidth,u)&&(e.checks.homogeneousSections[c].availableWidth=u,B.set(e))}function f(u){s.$$.not_equal(e.checks.homogeneousSections[c].notes1,u)&&(e.checks.homogeneousSections[c].notes1=u,B.set(e))}function d(u){s.$$.not_equal(e.checks.homogeneousSections[c].notes2,u)&&(e.checks.homogeneousSections[c].notes2=u,B.set(e))}const g=()=>p("delete");return s.$$set=u=>{"i"in u&&i(0,c=u.i)},[c,e,p,l,f,d,g]}class qe extends ue{constructor(t){super(),he(this,t,Ae,He,re,{i:0})}}function Ee(s){let t;return{c(){t=te("Delete")},l(i){t=ne(i,"Delete")},m(i,e){$(i,t,e)},d(i){i&&m(t)}}}function Ie(s){let t,i,e,c,p,l,f,d,g="Cross-Sections Possible: TODO",u,h,_,y,S,z,C,v,R;function W(o){s[3](o)}let D={label:"Location of constraint"};s[1].checks.pinchPoints[s[0]].location!==void 0&&(D.value=s[1].checks.pinchPoints[s[0]].location),i=new De({props:D}),X.push(()=>Z(i,"value",W));function x(o){s[4](o)}let U={label:"Available width (m)",width:3,min:0};s[1].checks.pinchPoints[s[0]].availableWidth!==void 0&&(U.value=s[1].checks.pinchPoints[s[0]].availableWidth),p=new Se({props:U}),X.push(()=>Z(p,"value",x));function L(o){s[5](o)}let F={label:"What will need to change to fit this in? Please leave a justification if space has been taken away from pedestrians or cyclists, or if shared use cycle tracks are proposed."};s[1].checks.pinchPoints[s[0]].notes1!==void 0&&(F.value=s[1].checks.pinchPoints[s[0]].notes1),h=new le({props:F}),X.push(()=>Z(h,"value",L));function j(o){s[6](o)}let b={label:"Where only the absolute minimum cross-section is possible, what (if anything) could change to fit in the desirable minimum cross-section? Where there is insufficient space even for the absolute minimum cross-section, what (if anything) could change to allow this to be implemented? Otherwise, what else could be implemented as an alternative?"};return s[1].checks.pinchPoints[s[0]].notes2!==void 0&&(b.value=s[1].checks.pinchPoints[s[0]].notes2),S=new le({props:b}),X.push(()=>Z(S,"value",j)),v=new Ce({props:{$$slots:{default:[Ee]},$$scope:{ctx:s}}}),v.$on("click",s[7]),{c(){t=V("div"),E(i.$$.fragment),c=w(),E(p.$$.fragment),f=w(),d=V("p"),d.textContent=g,u=w(),E(h.$$.fragment),y=w(),E(S.$$.fragment),C=w(),E(v.$$.fragment),this.h()},l(o){t=N(o,"DIV",{class:!0});var r=se(t);I(i.$$.fragment,r),c=P(r),I(p.$$.fragment,r),f=P(r),d=N(r,"P",{"data-svelte-h":!0}),ee(d)!=="svelte-9mzn0s"&&(d.textContent=g),u=P(r),I(h.$$.fragment,r),y=P(r),I(S.$$.fragment,r),C=P(r),I(v.$$.fragment,r),r.forEach(m),this.h()},h(){we(t,"class","svelte-d3f4io")},m(o,r){$(o,t,r),M(i,t,null),q(t,c),M(p,t,null),q(t,f),q(t,d),q(t,u),M(h,t,null),q(t,y),M(S,t,null),q(t,C),M(v,t,null),R=!0},p(o,[r]){const A={};!e&&r&3&&(e=!0,A.value=o[1].checks.pinchPoints[o[0]].location,Y(()=>e=!1)),i.$set(A);const J={};!l&&r&3&&(l=!0,J.value=o[1].checks.pinchPoints[o[0]].availableWidth,Y(()=>l=!1)),p.$set(J);const K={};!_&&r&3&&(_=!0,K.value=o[1].checks.pinchPoints[o[0]].notes1,Y(()=>_=!1)),h.$set(K);const Q={};!z&&r&3&&(z=!0,Q.value=o[1].checks.pinchPoints[o[0]].notes2,Y(()=>z=!1)),S.$set(Q);const n={};r&256&&(n.$$scope={dirty:r,ctx:o}),v.$set(n)},i(o){R||(T(i.$$.fragment,o),T(p.$$.fragment,o),T(h.$$.fragment,o),T(S.$$.fragment,o),T(v.$$.fragment,o),R=!0)},o(o){H(i.$$.fragment,o),H(p.$$.fragment,o),H(h.$$.fragment,o),H(S.$$.fragment,o),H(v.$$.fragment,o),R=!1},d(o){o&&m(t),O(i),O(p),O(h),O(S),O(v)}}}function Me(s,t,i){let e;ce(s,B,h=>i(1,e=h));let{i:c}=t,p=Pe();function l(h){s.$$.not_equal(e.checks.pinchPoints[c].location,h)&&(e.checks.pinchPoints[c].location=h,B.set(e))}function f(h){s.$$.not_equal(e.checks.pinchPoints[c].availableWidth,h)&&(e.checks.pinchPoints[c].availableWidth=h,B.set(e))}function d(h){s.$$.not_equal(e.checks.pinchPoints[c].notes1,h)&&(e.checks.pinchPoints[c].notes1=h,B.set(e))}function g(h){s.$$.not_equal(e.checks.pinchPoints[c].notes2,h)&&(e.checks.pinchPoints[c].notes2=h,B.set(e))}const u=()=>p("delete");return s.$$set=h=>{"i"in h&&i(0,c=h.i)},[c,e,p,l,f,d,g,u]}class Oe extends ue{constructor(t){super(),he(this,t,Me,Ie,re,{i:0})}}function ge(s,t,i){const e=s.slice();return e[7]=t[i],e[9]=i,e}function ve(s,t,i){const e=s.slice();return e[7]=t[i],e[9]=i,e}function Be(s){let t;return{c(){t=te("Add")},l(i){t=ne(i,"Add")},m(i,e){$(i,t,e)},d(i){i&&m(t)}}}function be(s,t){let i,e,c;function p(){return t[5](t[9])}return e=new qe({props:{i:t[9]}}),e.$on("delete",p),{key:s,first:null,c(){i=ae(),E(e.$$.fragment),this.h()},l(l){i=ae(),I(e.$$.fragment,l),this.h()},h(){this.first=i},m(l,f){$(l,i,f),M(e,l,f),c=!0},p(l,f){t=l;const d={};f&1&&(d.i=t[9]),e.$set(d)},i(l){c||(T(e.$$.fragment,l),c=!0)},o(l){H(e.$$.fragment,l),c=!1},d(l){l&&m(i),O(e,l)}}}function Le(s){let t;return{c(){t=te("Add")},l(i){t=ne(i,"Add")},m(i,e){$(i,t,e)},d(i){i&&m(t)}}}function ke(s,t){let i,e,c;function p(){return t[6](t[9])}return e=new Oe({props:{i:t[9]}}),e.$on("delete",p),{key:s,first:null,c(){i=ae(),E(e.$$.fragment),this.h()},l(l){i=ae(),I(e.$$.fragment,l),this.h()},h(){this.first=i},m(l,f){$(l,i,f),M(e,l,f),c=!0},p(l,f){t=l;const d={};f&1&&(d.i=t[9]),e.$set(d)},i(l){c||(T(e.$$.fragment,l),c=!0)},o(l){H(e.$$.fragment,l),c=!1},d(l){l&&m(i),O(e,l)}}}function je(s){let t,i,e,c=`Checking possible cross-sections of <u>homogeneous sections</u>
  of route along the proposed corridor`,p,l,f=`At regular intervals along the corridor measure and enter the available width
  to see if your proposed cross-sections can be accommodated`,d,g,u,h,_=[],y=new Map,S,z,C,v,R=`Checking possible cross-sections of any <u>constrained or atypical locations</u>
  along the proposed corridor`,W,D,x=`At key constraints along the corridor, measure and enter the available width
  to see if your proposed cross-sections can be accommodated`,U,L,F,j,b=[],o=new Map,r;t=new We({props:{links:[["Tools","/"],["Route cross-section","/cross_section"]],current:"Cross-Section Check"}}),g=new _e({props:{$$slots:{default:[Be]},$$scope:{ctx:s}}}),g.$on("click",s[1]);let A=oe(s[0].checks.homogeneousSections);const J=n=>n[9];for(let n=0;n<A.length;n+=1){let a=ve(s,A,n),k=J(a);y.set(k,_[n]=be(k,a))}L=new _e({props:{$$slots:{default:[Le]},$$scope:{ctx:s}}}),L.$on("click",s[3]);let K=oe(s[0].checks.pinchPoints);const Q=n=>n[9];for(let n=0;n<K.length;n+=1){let a=ge(s,K,n),k=Q(a);o.set(k,b[n]=ke(k,a))}return{c(){E(t.$$.fragment),i=w(),e=V("h2"),e.innerHTML=c,p=w(),l=V("p"),l.textContent=f,d=w(),E(g.$$.fragment),u=w(),h=V("div");for(let n=0;n<_.length;n+=1)_[n].c();S=w(),z=V("hr"),C=w(),v=V("h2"),v.innerHTML=R,W=w(),D=V("p"),D.textContent=x,U=w(),E(L.$$.fragment),F=w(),j=V("div");for(let n=0;n<b.length;n+=1)b[n].c();this.h()},l(n){I(t.$$.fragment,n),i=P(n),e=N(n,"H2",{"data-svelte-h":!0}),ee(e)!=="svelte-1x2x8kb"&&(e.innerHTML=c),p=P(n),l=N(n,"P",{"data-svelte-h":!0}),ee(l)!=="svelte-x0c18j"&&(l.textContent=f),d=P(n),I(g.$$.fragment,n),u=P(n),h=N(n,"DIV",{style:!0});var a=se(h);for(let G=0;G<_.length;G+=1)_[G].l(a);a.forEach(m),S=P(n),z=N(n,"HR",{}),C=P(n),v=N(n,"H2",{"data-svelte-h":!0}),ee(v)!=="svelte-1m1bgig"&&(v.innerHTML=R),W=P(n),D=N(n,"P",{"data-svelte-h":!0}),ee(D)!=="svelte-bdzwl6"&&(D.textContent=x),U=P(n),I(L.$$.fragment,n),F=P(n),j=N(n,"DIV",{style:!0});var k=se(j);for(let G=0;G<b.length;G+=1)b[G].l(k);k.forEach(m),this.h()},h(){ie(h,"display","flex"),ie(h,"flex-direction","row"),ie(j,"display","flex"),ie(j,"flex-direction","row")},m(n,a){M(t,n,a),$(n,i,a),$(n,e,a),$(n,p,a),$(n,l,a),$(n,d,a),M(g,n,a),$(n,u,a),$(n,h,a);for(let k=0;k<_.length;k+=1)_[k]&&_[k].m(h,null);$(n,S,a),$(n,z,a),$(n,C,a),$(n,v,a),$(n,W,a),$(n,D,a),$(n,U,a),M(L,n,a),$(n,F,a),$(n,j,a);for(let k=0;k<b.length;k+=1)b[k]&&b[k].m(j,null);r=!0},p(n,[a]){const k={};a&2048&&(k.$$scope={dirty:a,ctx:n}),g.$set(k),a&5&&(A=oe(n[0].checks.homogeneousSections),me(),_=de(_,a,J,1,n,A,y,h,$e,be,null,ve),pe());const G={};a&2048&&(G.$$scope={dirty:a,ctx:n}),L.$set(G),a&17&&(K=oe(n[0].checks.pinchPoints),me(),b=de(b,a,Q,1,n,K,o,j,$e,ke,null,ge),pe())},i(n){if(!r){T(t.$$.fragment,n),T(g.$$.fragment,n);for(let a=0;a<A.length;a+=1)T(_[a]);T(L.$$.fragment,n);for(let a=0;a<K.length;a+=1)T(b[a]);r=!0}},o(n){H(t.$$.fragment,n),H(g.$$.fragment,n);for(let a=0;a<_.length;a+=1)H(_[a]);H(L.$$.fragment,n);for(let a=0;a<b.length;a+=1)H(b[a]);r=!1},d(n){n&&(m(i),m(e),m(p),m(l),m(d),m(u),m(h),m(S),m(z),m(C),m(v),m(W),m(D),m(U),m(F),m(j)),O(t,n),O(g,n);for(let a=0;a<_.length;a+=1)_[a].d();O(L,n);for(let a=0;a<b.length;a+=1)b[a].d()}}}function ze(s,t,i){let e;ce(s,B,u=>i(0,e=u));function c(){fe(B,e.checks.homogeneousSections=[...e.checks.homogeneousSections,{availableWidth:0,notes1:"",notes2:""}],e)}function p(u){e.checks.homogeneousSections.splice(u,1),B.set(e)}function l(){fe(B,e.checks.pinchPoints=[...e.checks.pinchPoints,{location:"",availableWidth:0,notes1:"",notes2:""}],e)}function f(u){e.checks.pinchPoints.splice(u,1),B.set(e)}return[e,c,p,l,f,u=>p(u),u=>f(u)]}class Ye extends ue{constructor(t){super(),he(this,t,ze,je,re,{})}}export{Ye as component};
