import{s as Y,q as Z,w as D,a as P,e as B,t as ee,g as I,c as G,b as J,d as se,f as g,o as M,i as N,h as K,j as oe,u as ie,r as te,v as ne,x as F,k as ae}from"./scheduler.BKca8jgz.js";import{S as re,i as fe,e as Q,c as j,a as H,m as R,t as C,b as E,d as x}from"./index.CFqagxlr.js";import"./paths.DGjfiNGK.js";import{P as O,F as le}from"./PrevNext.C7anm4GK.js";import"./Geocoder.svelte_svelte_type_style_lang.CLPLPTv_.js";import{P as pe}from"./Progress.Dx21RiOk.js";import{s as z}from"./data.BMleuzla.js";function de(s){let n,p,t,h,m,a,l,d,u,S,r,$,v,V,k,o,_,c;n=new O({props:{idx:s[0],total:13,urlPath:"area_check/scorecard/q"}});const A=s[6].default,f=Z(A,s,s[5],null);u=new pe({props:{currentIdx:s[0]}});function T(e){s[7](e)}function U(e){s[8](e)}function W(e){s[9](e)}function X(e){s[10](e)}let w={choices:s[3]};return s[2].existingScores[s[0]-1]!==void 0&&(w.existingValue=s[2].existingScores[s[0]-1]),s[2].proposedScores[s[0]-1]!==void 0&&(w.proposedValue=s[2].proposedScores[s[0]-1]),s[2].existingScoreNotes[s[0]-1]!==void 0&&(w.existingNotes=s[2].existingScoreNotes[s[0]-1]),s[2].proposedScoreNotes[s[0]-1]!==void 0&&(w.proposedNotes=s[2].proposedScoreNotes[s[0]-1]),r=new le({props:w}),D.push(()=>Q(r,"existingValue",T)),D.push(()=>Q(r,"proposedValue",U)),D.push(()=>Q(r,"existingNotes",W)),D.push(()=>Q(r,"proposedNotes",X)),_=new O({props:{idx:s[0],total:13,urlPath:"area_check/scorecard/q"}}),{c(){j(n.$$.fragment),p=P(),t=B("h2"),h=ee(s[1]),m=P(),f&&f.c(),a=P(),l=B("div"),d=B("div"),j(u.$$.fragment),S=P(),j(r.$$.fragment),o=P(),j(_.$$.fragment),this.h()},l(e){H(n.$$.fragment,e),p=I(e),t=G(e,"H2",{});var i=J(t);h=se(i,s[1]),i.forEach(g),m=I(e),f&&f.l(e),a=I(e),l=G(e,"DIV",{class:!0});var b=J(l);d=G(b,"DIV",{class:!0});var q=J(d);H(u.$$.fragment,q),q.forEach(g),S=I(b),H(r.$$.fragment,b),b.forEach(g),o=I(e),H(_.$$.fragment,e),this.h()},h(){M(d,"class","progress-column svelte-1dlwx3z"),M(l,"class","columns svelte-1dlwx3z")},m(e,i){R(n,e,i),N(e,p,i),N(e,t,i),K(t,h),N(e,m,i),f&&f.m(e,i),N(e,a,i),N(e,l,i),K(l,d),R(u,d,null),K(l,S),R(r,l,null),N(e,o,i),R(_,e,i),c=!0},p(e,[i]){const b={};i&1&&(b.idx=e[0]),n.$set(b),(!c||i&2)&&oe(h,e[1]),f&&f.p&&(!c||i&32)&&ie(f,A,e,e[5],c?ne(A,e[5],i,null):te(e[5]),null);const q={};i&1&&(q.currentIdx=e[0]),u.$set(q);const y={};!$&&i&5&&($=!0,y.existingValue=e[2].existingScores[e[0]-1],F(()=>$=!1)),!v&&i&5&&(v=!0,y.proposedValue=e[2].proposedScores[e[0]-1],F(()=>v=!1)),!V&&i&5&&(V=!0,y.existingNotes=e[2].existingScoreNotes[e[0]-1],F(()=>V=!1)),!k&&i&5&&(k=!0,y.proposedNotes=e[2].proposedScoreNotes[e[0]-1],F(()=>k=!1)),r.$set(y);const L={};i&1&&(L.idx=e[0]),_.$set(L)},i(e){c||(C(n.$$.fragment,e),C(f,e),C(u.$$.fragment,e),C(r.$$.fragment,e),C(_.$$.fragment,e),c=!0)},o(e){E(n.$$.fragment,e),E(f,e),E(u.$$.fragment,e),E(r.$$.fragment,e),E(_.$$.fragment,e),c=!1},d(e){e&&(g(p),g(t),g(m),g(a),g(l),g(o)),x(n,e),f&&f.d(e),x(u),x(r),x(_,e)}}}function ue(s,n,p){let t;ae(s,z,o=>p(2,t=o));let{$$slots:h={},$$scope:m}=n,{idx:a}=n,{label:l}=n,{cases:d}=n,u=["#00b050","#99cc00","#ffc000","#ff5050","#ff0000"],S=["white","black","black","black","white"],r=d.map(([o,_],c)=>[o.toString(),_,u[c],S[c]]);function $(o){s.$$.not_equal(t.existingScores[a-1],o)&&(t.existingScores[a-1]=o,z.set(t))}function v(o){s.$$.not_equal(t.proposedScores[a-1],o)&&(t.proposedScores[a-1]=o,z.set(t))}function V(o){s.$$.not_equal(t.existingScoreNotes[a-1],o)&&(t.existingScoreNotes[a-1]=o,z.set(t))}function k(o){s.$$.not_equal(t.proposedScoreNotes[a-1],o)&&(t.proposedScoreNotes[a-1]=o,z.set(t))}return s.$$set=o=>{"idx"in o&&p(0,a=o.idx),"label"in o&&p(1,l=o.label),"cases"in o&&p(4,d=o.cases),"$$scope"in o&&p(5,m=o.$$scope)},[a,l,t,r,d,m,h,$,v,V,k]}class Se extends re{constructor(n){super(),fe(this,n,ue,de,Y,{idx:0,label:1,cases:4})}}export{Se as Q};
