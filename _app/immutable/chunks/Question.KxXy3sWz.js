import{s as Y,q as Z,B as D,a as P,e as A,t as ee,g as C,c as G,b as J,d as se,f as g,o as M,i as N,h as K,j as oe,w as ie,x as te,y as ne,C as F,k as ae}from"./scheduler.8BgUI7Rd.js";import{S as re,i as fe,e as Q,c as j,a as B,m as H,t as I,b as E,d as R}from"./index.lDYx8E-t.js";import"./paths.CaTQA5uW.js";import{P as O,F as le}from"./PrevNext.CPJn8kcP.js";import"./Modal.svelte_svelte_type_style_lang.B_YNrwyo.js";import{P as pe}from"./Progress.C9TfsOm2.js";import{s as z}from"./data.Bi4bYyIS.js";function de(s){let n,p,t,h,m,a,l,d,u,S,r,$,V,v,k,o,_,c;n=new O({props:{idx:s[0],total:13,urlPath:"area_check/scorecard/q"}});const x=s[6].default,f=Z(x,s,s[5],null);u=new pe({props:{currentIdx:s[0]}});function T(e){s[7](e)}function U(e){s[8](e)}function W(e){s[9](e)}function X(e){s[10](e)}let w={choices:s[3]};return s[2].existingScores[s[0]-1]!==void 0&&(w.existingValue=s[2].existingScores[s[0]-1]),s[2].proposedScores[s[0]-1]!==void 0&&(w.proposedValue=s[2].proposedScores[s[0]-1]),s[2].existingScoreNotes[s[0]-1]!==void 0&&(w.existingNotes=s[2].existingScoreNotes[s[0]-1]),s[2].proposedScoreNotes[s[0]-1]!==void 0&&(w.proposedNotes=s[2].proposedScoreNotes[s[0]-1]),r=new le({props:w}),D.push(()=>Q(r,"existingValue",T)),D.push(()=>Q(r,"proposedValue",U)),D.push(()=>Q(r,"existingNotes",W)),D.push(()=>Q(r,"proposedNotes",X)),_=new O({props:{idx:s[0],total:13,urlPath:"area_check/scorecard/q"}}),{c(){j(n.$$.fragment),p=P(),t=A("h2"),h=ee(s[1]),m=P(),f&&f.c(),a=P(),l=A("div"),d=A("div"),j(u.$$.fragment),S=P(),j(r.$$.fragment),o=P(),j(_.$$.fragment),this.h()},l(e){B(n.$$.fragment,e),p=C(e),t=G(e,"H2",{});var i=J(t);h=se(i,s[1]),i.forEach(g),m=C(e),f&&f.l(e),a=C(e),l=G(e,"DIV",{class:!0});var b=J(l);d=G(b,"DIV",{class:!0});var q=J(d);B(u.$$.fragment,q),q.forEach(g),S=C(b),B(r.$$.fragment,b),b.forEach(g),o=C(e),B(_.$$.fragment,e),this.h()},h(){M(d,"class","progress-column svelte-1dlwx3z"),M(l,"class","columns svelte-1dlwx3z")},m(e,i){H(n,e,i),N(e,p,i),N(e,t,i),K(t,h),N(e,m,i),f&&f.m(e,i),N(e,a,i),N(e,l,i),K(l,d),H(u,d,null),K(l,S),H(r,l,null),N(e,o,i),H(_,e,i),c=!0},p(e,[i]){const b={};i&1&&(b.idx=e[0]),n.$set(b),(!c||i&2)&&oe(h,e[1]),f&&f.p&&(!c||i&32)&&ie(f,x,e,e[5],c?ne(x,e[5],i,null):te(e[5]),null);const q={};i&1&&(q.currentIdx=e[0]),u.$set(q);const y={};!$&&i&5&&($=!0,y.existingValue=e[2].existingScores[e[0]-1],F(()=>$=!1)),!V&&i&5&&(V=!0,y.proposedValue=e[2].proposedScores[e[0]-1],F(()=>V=!1)),!v&&i&5&&(v=!0,y.existingNotes=e[2].existingScoreNotes[e[0]-1],F(()=>v=!1)),!k&&i&5&&(k=!0,y.proposedNotes=e[2].proposedScoreNotes[e[0]-1],F(()=>k=!1)),r.$set(y);const L={};i&1&&(L.idx=e[0]),_.$set(L)},i(e){c||(I(n.$$.fragment,e),I(f,e),I(u.$$.fragment,e),I(r.$$.fragment,e),I(_.$$.fragment,e),c=!0)},o(e){E(n.$$.fragment,e),E(f,e),E(u.$$.fragment,e),E(r.$$.fragment,e),E(_.$$.fragment,e),c=!1},d(e){e&&(g(p),g(t),g(m),g(a),g(l),g(o)),R(n,e),f&&f.d(e),R(u),R(r),R(_,e)}}}function ue(s,n,p){let t;ae(s,z,o=>p(2,t=o));let{$$slots:h={},$$scope:m}=n,{idx:a}=n,{label:l}=n,{cases:d}=n,u=["#00b050","#99cc00","#ffc000","#ff5050","#ff0000"],S=["white","black","black","black","white"],r=d.map(([o,_],c)=>[o.toString(),_,u[c],S[c]]);function $(o){s.$$.not_equal(t.existingScores[a-1],o)&&(t.existingScores[a-1]=o,z.set(t))}function V(o){s.$$.not_equal(t.proposedScores[a-1],o)&&(t.proposedScores[a-1]=o,z.set(t))}function v(o){s.$$.not_equal(t.existingScoreNotes[a-1],o)&&(t.existingScoreNotes[a-1]=o,z.set(t))}function k(o){s.$$.not_equal(t.proposedScoreNotes[a-1],o)&&(t.proposedScoreNotes[a-1]=o,z.set(t))}return s.$$set=o=>{"idx"in o&&p(0,a=o.idx),"label"in o&&p(1,l=o.label),"cases"in o&&p(4,d=o.cases),"$$scope"in o&&p(5,m=o.$$scope)},[a,l,t,r,d,m,h,$,V,v,k]}class Se extends re{constructor(n){super(),fe(this,n,ue,de,Y,{idx:0,label:1,cases:4})}}export{Se as Q};
