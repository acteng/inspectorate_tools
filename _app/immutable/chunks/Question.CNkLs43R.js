import{s as se,m as oe,x as H,a as k,e as J,t as te,c as v,b as K,f as L,h as ie,d,o as W,i as N,j as M,B as ne,u as ae,p as re,q as fe,y as R,k as le}from"./scheduler.CKOt2LAZ.js";import{S as pe,i as ue,e as T,c as A,a as D,m as F,t as w,b as q,d as Q}from"./index.BDxETPF1.js";import{B as de}from"./Geocoder.svelte_svelte_type_style_lang.AsJd5zsu.js";import{P as X,F as ce}from"./PrevNext.CtFB9v_A.js";import{P as _e}from"./Progress.Zmo31ibq.js";import{s as j}from"./data.BjGq9rph.js";function me(s){let n,p,i,V,c,a,b,_,l,m,u,y,r,P,I,o,B,$,g,h;n=new de({props:{links:[["Tools","/"],["Area check tool","/area_check"],["Area Scorecard","/area_check/scorecard"]],current:s[1]}}),i=new X({props:{idx:s[0],total:13,urlPath:"area_check/scorecard/q"}});const G=s[6].default,f=oe(G,s,s[5],null);u=new _e({props:{currentIdx:s[0]}});function Y(e){s[7](e)}function Z(e){s[8](e)}function x(e){s[9](e)}function ee(e){s[10](e)}let C={choices:s[3]};return s[2].existingScores[s[0]-1]!==void 0&&(C.existingValue=s[2].existingScores[s[0]-1]),s[2].proposedScores[s[0]-1]!==void 0&&(C.proposedValue=s[2].proposedScores[s[0]-1]),s[2].existingScoreNotes[s[0]-1]!==void 0&&(C.existingNotes=s[2].existingScoreNotes[s[0]-1]),s[2].proposedScoreNotes[s[0]-1]!==void 0&&(C.proposedNotes=s[2].proposedScoreNotes[s[0]-1]),r=new ce({props:C}),H.push(()=>T(r,"existingValue",Y)),H.push(()=>T(r,"proposedValue",Z)),H.push(()=>T(r,"existingNotes",x)),H.push(()=>T(r,"proposedNotes",ee)),g=new X({props:{idx:s[0],total:13,urlPath:"area_check/scorecard/q"}}),{c(){A(n.$$.fragment),p=k(),A(i.$$.fragment),V=k(),c=J("h2"),a=te(s[1]),b=k(),f&&f.c(),_=k(),l=J("div"),m=J("div"),A(u.$$.fragment),y=k(),A(r.$$.fragment),$=k(),A(g.$$.fragment),this.h()},l(e){D(n.$$.fragment,e),p=v(e),D(i.$$.fragment,e),V=v(e),c=K(e,"H2",{});var t=L(c);a=ie(t,s[1]),t.forEach(d),b=v(e),f&&f.l(e),_=v(e),l=K(e,"DIV",{class:!0});var S=L(l);m=K(S,"DIV",{class:!0});var E=L(m);D(u.$$.fragment,E),E.forEach(d),y=v(S),D(r.$$.fragment,S),S.forEach(d),$=v(e),D(g.$$.fragment,e),this.h()},h(){W(m,"class","progress-column svelte-1dlwx3z"),W(l,"class","columns svelte-1dlwx3z")},m(e,t){F(n,e,t),N(e,p,t),F(i,e,t),N(e,V,t),N(e,c,t),M(c,a),N(e,b,t),f&&f.m(e,t),N(e,_,t),N(e,l,t),M(l,m),F(u,m,null),M(l,y),F(r,l,null),N(e,$,t),F(g,e,t),h=!0},p(e,[t]){const S={};t&2&&(S.current=e[1]),n.$set(S);const E={};t&1&&(E.idx=e[0]),i.$set(E),(!h||t&2)&&ne(a,e[1]),f&&f.p&&(!h||t&32)&&ae(f,G,e,e[5],h?fe(G,e[5],t,null):re(e[5]),null);const O={};t&1&&(O.currentIdx=e[0]),u.$set(O);const z={};!P&&t&5&&(P=!0,z.existingValue=e[2].existingScores[e[0]-1],R(()=>P=!1)),!I&&t&5&&(I=!0,z.proposedValue=e[2].proposedScores[e[0]-1],R(()=>I=!1)),!o&&t&5&&(o=!0,z.existingNotes=e[2].existingScoreNotes[e[0]-1],R(()=>o=!1)),!B&&t&5&&(B=!0,z.proposedNotes=e[2].proposedScoreNotes[e[0]-1],R(()=>B=!1)),r.$set(z);const U={};t&1&&(U.idx=e[0]),g.$set(U)},i(e){h||(w(n.$$.fragment,e),w(i.$$.fragment,e),w(f,e),w(u.$$.fragment,e),w(r.$$.fragment,e),w(g.$$.fragment,e),h=!0)},o(e){q(n.$$.fragment,e),q(i.$$.fragment,e),q(f,e),q(u.$$.fragment,e),q(r.$$.fragment,e),q(g.$$.fragment,e),h=!1},d(e){e&&(d(p),d(V),d(c),d(b),d(_),d(l),d($)),Q(n,e),Q(i,e),f&&f.d(e),Q(u),Q(r),Q(g,e)}}}function ge(s,n,p){let i;le(s,j,o=>p(2,i=o));let{$$slots:V={},$$scope:c}=n,{idx:a}=n,{label:b}=n,{cases:_}=n,l=["#00b050","#99cc00","#ffc000","#ff5050","#ff0000"],m=["white","black","black","black","white"],u=_.map(([o,B],$)=>[o.toString(),B,l[$],m[$]]);function y(o){s.$$.not_equal(i.existingScores[a-1],o)&&(i.existingScores[a-1]=o,j.set(i))}function r(o){s.$$.not_equal(i.proposedScores[a-1],o)&&(i.proposedScores[a-1]=o,j.set(i))}function P(o){s.$$.not_equal(i.existingScoreNotes[a-1],o)&&(i.existingScoreNotes[a-1]=o,j.set(i))}function I(o){s.$$.not_equal(i.proposedScoreNotes[a-1],o)&&(i.proposedScoreNotes[a-1]=o,j.set(i))}return s.$$set=o=>{"idx"in o&&p(0,a=o.idx),"label"in o&&p(1,b=o.label),"cases"in o&&p(4,_=o.cases),"$$scope"in o&&p(5,c=o.$$scope)},[a,b,i,u,_,c,V,y,r,P,I]}class ke extends pe{constructor(n){super(),ue(this,n,ge,me,se,{idx:0,label:1,cases:4})}}export{ke as Q};
